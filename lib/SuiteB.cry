module SuiteB where

/***** AES ******/

type AES128 = 4
type AES192 = 6
type AES256 = 8

type AESRoundKey = [4][32]

type AESEncryptKeySchedule k =
  { aesEncInitialKey : AESRoundKey
  , aesEncRoundKeys  : [k+5]AESRoundKey
  , aesEncFinalKey   : AESRoundKey
  }

type AESDecryptKeySchedule k =
  { aesDecInitialKey : AESRoundKey
  , aesDecRoundKeys  : [k+5]AESRoundKey
  , aesDecFinalKey   : AESRoundKey
  }


aes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128
aes128EncryptSchedule = aesExpandEncryptSchedule

aes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128
aes128DecryptSchedule = aesExpandDecryptSchedule

aes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)
aes128Schedules = aesExpandSchedules


aes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192
aes192EncryptSchedule = aesExpandEncryptSchedule

aes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192
aes192DecryptSchedule = aesExpandDecryptSchedule

aes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)
aes192Schedules = aesExpandSchedules


aes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256
aes256EncryptSchedule = aesExpandEncryptSchedule

aes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256
aes256DecryptSchedule = aesExpandDecryptSchedule

aes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)
aes256Schedules = aesExpandSchedules


aesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]
aesEncryptBlock schedule plaintext = rnf (join final)
  where
  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey

  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #
        [ AESEncRound r ^ rdk
        | rdk <- schedule.aesEncRoundKeys
        | r   <- rds
        ]

aesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]
aesDecryptBlock schedule cyphertext = rnf (join final)
  where
  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey

  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #
        [ AESDecRound r ^ rdk
	| rdk <- schedule.aesDecRoundKeys
	| r   <- rds
	]


private
  aesExpandEncryptSchedule : {k} (fin k, k >= 4) => [k * 32] -> AESEncryptKeySchedule k
  aesExpandEncryptSchedule key = rnf
       { aesEncInitialKey = ks @  0
       , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]
       , aesEncFinalKey   = ks @  `(k+6)
       }
    where
    ks : [inf]AESRoundKey
    ks = groupBy`{4} (AESKeyInfExpand`{k} (split key))
  
  aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k
  aesEncToDecSchedule enc = rnf
     { aesDecInitialKey = enc.aesEncFinalKey
     , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))
     , aesDecFinalKey   = enc.aesEncInitialKey
     }

  aesExpandDecryptSchedule : {k} (fin k, k >= 4) => [k * 32] -> AESDecryptKeySchedule k
  aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)

  aesExpandSchedules : {k} (fin k, k >= 4) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)
  aesExpandSchedules key = (encS, aesEncToDecSchedule encS)
    where encS = aesExpandEncryptSchedule key
  
  primitive AESEncRound      : [4][32] -> [4][32]
  primitive AESEncFinalRound : [4][32] -> [4][32]
  primitive AESDecRound      : [4][32] -> [4][32]
  primitive AESDecFinalRound : [4][32] -> [4][32]
  primitive AESInvMixColumns : [4][32] -> [4][32]
  primitive AESKeyInfExpand  : {k} (fin k, k >= 4) => [k][32] -> [inf][32]

/***** SHA2 *****/

sha224 : {L} (fin L) => [L] -> [224]
sha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))

sha256 : {L} (fin L) => [L] -> [256]
sha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))

sha384 : {L} (fin L) => [L] -> [384]
sha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))

sha512 : {L} (fin L) => [L] -> [512]
sha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))

private
    type sha2_block_size w = 16 * w
    type sha2_num_blocks w L = (L+1+2*w) /^ sha2_block_size w
    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w

    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]
    sha2pad M = M # 0b1 # zero # ((fromInteger `L) : [2*w])

    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>
      [L] -> [sha2_num_blocks w L][16][w]
    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]

    /**
     * Apply the SHA224 hash algorithm to a sequence of SHA256-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]

    /**
     * Apply the SHA256 hash algorithm to a sequence of SHA256-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]

    /**
     * Apply the SHA384 hash algorithm to a sequence of SHA512-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]

    /**
     * Apply the SHA512 hash algorithm to a sequence of SHA512-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]
