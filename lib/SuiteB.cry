module SuiteB where

/***** AES ******/

type AES128 = 4
type AES192 = 6
type AES256 = 8

type AESRoundKey = [4][32]

type AESEncryptKeySchedule k =
  { aesEncInitialKey : AESRoundKey
  , aesEncRoundKeys  : [k+5]AESRoundKey
  , aesEncFinalKey   : AESRoundKey
  }

type AESDecryptKeySchedule k =
  { aesDecInitialKey : AESRoundKey
  , aesDecRoundKeys  : [k+5]AESRoundKey
  , aesDecFinalKey   : AESRoundKey
  }

aesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]
aesEncryptBlock schedule plaintext = join final
  where
  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey

  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #
        [ AESEncRound r ^ rdk
        | rdk <- schedule.aesEncRoundKeys
        | r   <- rds
        ]

aesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]
aesDecryptBlock schedule cyphertext = join final
  where
  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey

  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #
        [ AESDecRound r ^ rdk
	| rdk <- schedule.aesDecRoundKeys
	| r   <- rds
	]

aesExpandSchedules : {k} (fin k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)
aesExpandSchedules key = (encS, aesEncToDecSchedule encS)
  where encS = aesExpandEncryptSchedule key

aesExpandEncryptSchedule : {k} (fin k) => [k * 32] -> AESEncryptKeySchedule k
aesExpandEncryptSchedule key = rnf
     { aesEncInitialKey = ks @  0
     , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]
     , aesEncFinalKey   = ks @  `(k+6)
     }
  where
  ks : [inf]AESRoundKey
  ks = groupBy`{4} (AESKeyInfExpand`{k} (split key))

aesExpandDecryptSchedule : {k} (fin k) => [k * 32] -> AESDecryptKeySchedule k
aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)

private
  aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k
  aesEncToDecSchedule enc = rnf
     { aesDecInitialKey = enc.aesEncFinalKey
     , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))
     , aesDecFinalKey   = enc.aesEncInitialKey
     }

  primitive AESEncRound      : [4][32] -> [4][32]
  primitive AESEncFinalRound : [4][32] -> [4][32]
  primitive AESDecRound      : [4][32] -> [4][32]
  primitive AESDecFinalRound : [4][32] -> [4][32]
  primitive AESInvMixColumns : [4][32] -> [4][32]
  primitive AESKeyInfExpand : {k} (fin k) => [k][32] -> [inf][32]

/***** SHA2 *****/

sha224 : {L} (fin L) => [L] -> [224]
sha224 msg = join (accelSHA2_224 (sha2blocks`{32} msg))

sha256 : {L} (fin L) => [L] -> [256]
sha256 msg = join (accelSHA2_256 (sha2blocks`{32} msg))

sha384 : {L} (fin L) => [L] -> [384]
sha384 msg = join (accelSHA2_384 (sha2blocks`{64} msg))

sha512 : {L} (fin L) => [L] -> [512]
sha512 msg = join (accelSHA2_512 (sha2blocks`{64} msg))

private
    type sha2_block_size w = 16 * w
    type sha2_num_blocks w L = (L+1+2*w) /^ sha2_block_size w
    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w

    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]
    sha2pad M = M # 0b1 # zero # ((fromInteger `L) : [2*w])

    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>
      [L] -> [sha2_num_blocks w L][16][w]
    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]

    /**
     * Apply the SHA224 hash algorithm to a sequence of SHA256-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive accelSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]

    /**
     * Apply the SHA256 hash algorithm to a sequence of SHA256-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive accelSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]

    /**
     * Apply the SHA384 hash algorithm to a sequence of SHA512-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive accelSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]

    /**
     * Apply the SHA512 hash algorithm to a sequence of SHA512-size blocks,
     * which are assumed to already be correctly padded.
     */
    primitive accelSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]
