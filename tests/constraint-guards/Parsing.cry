module Parsing where

// Constraints are parsed the same as types

foo : {n} [n] -> [n]
foo x = x

l : {n} fin n => [n] -> [n]
l _ = `n

// f : {n} [n] -> [n]
// f .. x = x

// f : {n} [n] -> [n]
// f .. (fin n) .. x = x

// f : {n} [n] -> [n]
// f <| (fin n, n == 1) => |> x = x

// f : {n} fin n
// f = undefined

// f : {n} ([n], [n], [n])
// f = undefined

// f : {n} (n == 1) => [n] -> [n]
// f x = x

// f : {n} fin n => fin n => [1] -> [1]
// f x = x

// Tests

// f : {n} [n] -> [n]
// f <| (n == 1) => |> x = x

// f : {n} [n] -> [n]
// f x = x

// g : {n} (fin n) => [n] -> [n]
// g <| (n == 0) |> _ = []

// g' : {n} [n] -> [n]
// g' <| (n == 1) |> x = x

// FAILS when evaluated on [1,2]
f : {n} [n] -> [8]
f x
  | n == 1 => g1 x // passes
  | n == 2 => g2 x // passes
  | n == 3 => g3 x // passes
  // | n == n => g4 x // fails

g1 : {n} (n == 1) => [n] -> [8]
g1 x = 1

g2 : {n} (n == 2) => [n] -> [8]
g2 x = 2

g3 : {n} (n == 3) => [n] -> [8]
g3 x = 3

g4 : {n} (n == 4) => [n] -> [8]
g4 x = 4


