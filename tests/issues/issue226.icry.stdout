Loading module Cryptol
Loading module Cryptol
Loading module issue226r2
Loading module issue226
Type Synonyms
=============
    type Bool = Bit
    type Char = [8]
    type lg2 n = width (max 1 n - 1)
    type String n = [n][8]
    type Word n = [n]

Symbols
=======
    (==>) : Bit -> Bit -> Bit
    (\/) : Bit -> Bit -> Bit
    (/\) : Bit -> Bit -> Bit
    (!=) : {a} (Cmp a) => a -> a -> Bit
    (!==) : {a, b} (Cmp b) => (a -> b) -> (a -> b) -> a -> Bit
    (==) : {a} (Cmp a) => a -> a -> Bit
    (===) : {a, b} (Cmp b) => (a -> b) -> (a -> b) -> a -> Bit
    (<) : {a} (Cmp a) => a -> a -> Bit
    (<$) : {a} (SignedCmp a) => a -> a -> Bit
    (<=) : {a} (Cmp a) => a -> a -> Bit
    (<=$) : {a} (SignedCmp a) => a -> a -> Bit
    (>) : {a} (Cmp a) => a -> a -> Bit
    (>$) : {a} (SignedCmp a) => a -> a -> Bit
    (>=) : {a} (Cmp a) => a -> a -> Bit
    (>=$) : {a} (SignedCmp a) => a -> a -> Bit
    (||) : {a} (Logic a) => a -> a -> a
    (^) : {a} (Logic a) => a -> a -> a
    (&&) : {a} (Logic a) => a -> a -> a
    (#) :
      {front, back, a} (fin front) =>
        [front]a -> [back]a -> [front + back]a
    (<<) : {a, b, c} (fin b, Zero c) => [a]c -> [b] -> [a]c
    (<<<) : {a, b, c} (fin a, fin b) => [a]c -> [b] -> [a]c
    (>>) : {a, b, c} (fin b, Zero c) => [a]c -> [b] -> [a]c
    (>>$) : {n, k} (fin n, n >= 1, fin k) => [n] -> [k] -> [n]
    (>>>) : {a, b, c} (fin a, fin b) => [a]c -> [b] -> [a]c
    (+) : {a} (Arith a) => a -> a -> a
    (-) : {a} (Arith a) => a -> a -> a
    (%) : {a} (Arith a) => a -> a -> a
    (%$) : {a} (Arith a) => a -> a -> a
    (*) : {a} (Arith a) => a -> a -> a
    (/) : {a} (Arith a) => a -> a -> a
    (/$) : {a} (Arith a) => a -> a -> a
    (^^) : {a} (Arith a) => a -> a -> a
    (!) : {a, b, c} (fin a, fin c) => [a]b -> [c] -> b
    (!!) : {a, b, c, d} (fin a, fin d) => [a]b -> [c][d] -> [c]b
    (@) : {a, b, c} (fin c) => [a]b -> [c] -> b
    (@@) : {a, b, c, d} (fin d) => [a]b -> [c][d] -> [c]b
    all : {a, n} (fin n) => (a -> Bit) -> [n]a -> Bit
    and : {n} (fin n) => [n] -> Bit
    any : {a, n} (fin n) => (a -> Bit) -> [n]a -> Bit
    carry : {n} (fin n) => [n] -> [n] -> Bit
    complement : {a} (Logic a) => a -> a
    curry : {a, b, c} ((a, b) -> c) -> a -> b -> c
    demote : {val, rep} (Literal val rep) => rep
    drop :
      {front, back, elem} (fin front) => [front + back]elem -> [back]elem
    elem : {n, a} (fin n, Cmp a) => a -> [n]a -> Bit
    error : {at, len} (fin len) => [len][8] -> at
    False : Bit
    foldl : {a, b, n} (fin n) => (a -> b -> a) -> a -> [n]b -> a
    foldr : {a, b, n} (fin n) => (a -> b -> b) -> b -> [n]a -> b
    foo : {a} a -> a
    fromInteger : {a} (Arith a) => Integer -> a
    fromThen :
      {first, next, bits, len} (fin first, fin next, fin bits,
                                bits >= width first, bits >= width next,
                                lengthFromThen first next bits == len) =>
        [len][bits]
    fromThenTo :
      {first, next, last, a, len} (fin first, fin next, fin last,
                                   Literal first a, Literal next a, Literal last a,
                                   lengthFromThenTo first next last == len) =>
        [len]a
    fromTo :
      {first, last, a} (fin last, last >= first, Literal last a) =>
        [1 + (last - first)]a
    fromZ : {n} (fin n, n >= 1) => Z n -> Integer
    groupBy :
      {each, parts, elem} (fin each) =>
        [each * parts]elem -> [parts][each]elem
    head : {a, b} [1 + a]b -> b
    infFrom : {bits} (fin bits) => [bits] -> [inf][bits]
    infFromThen : {bits} (fin bits) => [bits] -> [bits] -> [inf][bits]
    iterate : {a} (a -> a) -> a -> [inf]a
    join :
      {parts, each, a} (fin each) => [parts][each]a -> [parts * each]a
    last : {a, b} (fin a) => [1 + a]b -> b
    lg2 : {a} (Arith a) => a -> a
    map : {a, b, n} (a -> b) -> [n]a -> [n]b
    max : {a} (Cmp a) => a -> a -> a
    min : {a} (Cmp a) => a -> a -> a
    negate : {a} (Arith a) => a -> a
    or : {n} (fin n) => [n] -> Bit
    pdiv : {a, b} (fin a, fin b) => [a] -> [b] -> [a]
    pmod : {a, b} (fin a, fin b) => [a] -> [1 + b] -> [b]
    pmult :
      {a, b} (fin a, fin b) => [1 + a] -> [1 + b] -> [1 + (a + b)]
    random : {a} [256] -> a
    repeat : {n, a} a -> [n]a
    reverse : {a, b} (fin a) => [a]b -> [a]b
    sborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit
    scanl : {b, a, n} (b -> a -> b) -> b -> [n]a -> [1 + n]b
    scanr : {a, b, n} (fin n) => (a -> b -> b) -> b -> [n]a -> [1 + n]b
    scarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit
    sext : {n, m} (fin m, m >= n, n >= 1) => [n] -> [m]
    split :
      {parts, each, a} (fin each) => [parts * each]a -> [parts][each]a
    splitAt :
      {front, back, a} (fin front) =>
        [front + back]a -> ([front]a, [back]a)
    sum : {a, n} (fin n, Zero a, Arith a) => [n]a -> a
    True : Bit
    tail : {a, b} [1 + a]b -> [a]b
    take :
      {front, back, elem} (fin front) =>
        [front + back]elem -> [front]elem
    toInteger : {a} (fin a) => [a] -> Integer
    toZ : {n} (fin n, n >= 1) => Integer -> Z n
    trace : {n, a, b} (fin n) => [n][8] -> a -> b -> b
    traceVal : {n, a} (fin n) => [n][8] -> a -> a
    transpose : {a, b, c} [a][b]c -> [b][a]c
    uncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c
    undefined : {a} a
    update : {a, b, c} (fin c) => [a]b -> [c] -> b -> [a]b
    updateEnd : {a, b, c} (fin a, fin c) => [a]b -> [c] -> b -> [a]b
    updates :
      {a, b, c, d} (fin c, fin d) => [a]b -> [d][c] -> [d]b -> [a]b
    updatesEnd :
      {a, b, c, d} (fin a, fin c, fin d) =>
        [a]b -> [d][c] -> [d]b -> [a]b
    width :
      {bits, len, elem} (fin len, fin bits, bits >= width len) =>
        [len]elem -> [bits]
    zero : {a} (Zero a) => a
    zext : {n, m} (fin m, m >= n) => [n] -> [m]
    zip : {a, b, n} [n]a -> [n]b -> [n](a, b)
    zipWith : {a, b, c, n} (a -> b -> c) -> [n]a -> [n]b -> [n]c

